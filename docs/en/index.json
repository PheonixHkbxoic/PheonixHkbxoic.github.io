[{"content":"Array 数组是存放在连续内存空间上的相同类型数据的集合。查询简单，增加和删除困难。\n数组可以通过下标快速访问数组元素。但是因为数组在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。数组的元素是不能删的，只能覆盖。\n二维数组在内存的空间地址也是连续的\n一、声明与赋值 1 2 3 4 var a [3]int var b = [3]int{1,2,3} c := [3]int{1,2,3} d := [...]int{1,2,3} 数组是内存中一片连续的区域，跟Slice，Map等结构体完全不一样\n需要指定长度，是个常量，不能动态指定，[\u0026hellip;]方式在编译时自动推断\n元素类型相同\n是值类型，类型与长度都相同时才被认为两个数组是同类型\n二、编译时检测、内存分配 数组在编译阶段最终被解析为types.Array类型，包含元素类型Elem和数组长度Bound\n1 2 3 4 5 // Array contains Type fields specific to array types. type Array struct { Elem *Type // element type Bound int64 // number of elements; \u0026lt;0 if unknown yet } 并会进行类型检查 ，索引越界检查\n三、运行时 当编译时无法判断是否越界时，SSA生成 IsInBounds 越界检查指令，若越界，触发 PanicBounds 指令执行 runtime.panicIndex\n运行时通过newarray()函数对数组内存进行分配，如果数组大小不超过32kb则会直接分配到栈上， 否则分配到堆区内存\n四、注意 Go中的传值方式是按值传递，这意味着给变量赋值、给函数传参时，都是直接拷贝一个副本然后将副本赋值给对方的。这样的拷贝方式意味着：\n如果数据结构体积庞大，则要完整拷贝一个数据结构副本时效率会很低 函数内部修改数据结构时，只能在函数内部生效，函数一退出就失效了，因为它修改的是副本对象 五、参考 golang数组内存分配原理_Golang_脚本之家\n","permalink":"https://PheonixHkbxoic.github.io/docs/en/posts/golang/array/","summary":"数组是内存中一片连续的区域，固定长度，元素类型相同，是值类型，大数组值参等值传递效率低 编译时进行类型检查 ，索引越界检查","title":"Go: Array"},{"content":"Map ","permalink":"https://PheonixHkbxoic.github.io/docs/en/posts/golang/map/","summary":"Map","title":"Go: Map"},{"content":"slice 切片是不定长的特定元素类型的序列,可以理解为动态数组\nGo语言中，数组在传递的时候，传递的是原数组的拷贝，对大数组来说，内存代价会非常大，影响性能。\n传递数组指针可以解决这个问题，但是数组指针也有一个弊端：原数组的指针指向改变了，那函数里面的指针指向也会跟着改变，某些情况下，可能会产生意想不到的bug。slice的出现，便是为了解决这个问题。\n一、特点 长度不固定 切片是引用类型，一般来说是浅拷贝 切片本身不能存储任何数据，都是底层数组存储数据，修改切片的时候修改的是底层数组中的数据，切片一旦扩容，会指向一个新的底层数组，内存地址也就随之改变。 底层实现是一个结构体，包括长度、容量和一个指向实际数组的unsafe.Pointer指针 1 2 3 4 5 type slice struct { array unsafe.Pointer // 指向底层数组的指针 len int // 长度 cap int // 容量 } 注意：\n底层数组是可以被多个 slice 同时指向的，因此对一个 slice 的元素进行操作是有可能影响到其他 slice 的。\n二、扩容规则 如果扩容需求大于当前容量的两倍，扩容后的容量为所需的最小容量 当前切片长度\u0026lt;1024,扩容当前容量为2倍， 当前切片长度\u0026gt;1024,每次扩容当前容量的1.25倍，循环扩容直至容量满足需求\n切片扩容之后，指向匿名数组的指针地址会发生变化。 1.18 引入了新的扩容规则，首先 1024 的边界不复存在，取而代之的常量是 256 。超出256的情况，也不是直接扩容25%，而是设计了一个平滑过渡的计算方法，随着容量增大，扩容比例逐渐从100%平滑降低到25%，从 2 倍平滑过渡到 1.25 倍。\n为什么要这样设计？\n避免追加过程中频繁扩容，减少内存分配和数据复制开销，有助于性能提升。\n计算出了新容量之后，还没有完，出于内存的高效利用考虑，还要进行内存对齐。进行内存对齐之后，新 slice 的容量是要 大于等于 老 slice 容量的 2倍或者1.25倍。\n三、声明与赋值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 只声明 var a = []string // 声明，使用字面量初始化 var b = []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;} // 从已有数组或切片生成 var c = b[1:] // 使用make生成 可以指定长度，容量 var d = make([]string, 3) var d = make([]string, 3, 8) // new方式创建的是指针 var e *[]int = new([]int) 注意：\n只声明的切片 等于nil，长度与容量都为0 make([]string, 0, 0)赋值的切片，长度与容量都为0，但不是nil make会用零值0初始化所有元素, cap可心省略(默认等于长度) 四、切片slice和数组array的关系 切片slice的底层是对数组array的引用；\n切片可以引用数组的部分元素或者全部元素；\n切片slice的指针指向的是切片的第一个元素的内存地址，也就是该元素对应的数组的元素的内存地址。\n五、切片操作 len,cap 可以查看切片的长度与容量\nappend s = append(s, “x”)\ns作为参数传给函数append是值传递，是结构体的拷贝，底层数组的指针一样\n底层数组加了一个元素，s拷贝的长度也会跟着变，但s的长度没变啊，所以s要重新赋值\n另外如果扩容了s拷贝的底层数组指针会变, 长度，容量也会变，但原来的s什么都不会变，所以s也要重新赋值\n值的过程复制一个新的切片，这个切片也指向原始变量的底层数组。\n函数中无论是直接修改切片，还是append创建新的切片，都是基于共享切片底层数组的情况作为基础，\n最外面的原始切片是否改变，取决于函数内的操作和切片本身容量，是否修改了底层数组。\n如果要修改切片的值，那么一定对底层数组做了修改，为影响到函数外的切片 如果是append操作，则要看切片是否扩容 切片没有进行扩容，那么会直接添加或修改切片指向底层数组中后一位的值，故底层数组会受到改变，函数外切片改变； 而如果进行扩容，则会导致切片指向一个新的底层数组，一切修改都对函数外的原切片无影响 访问 切片的引用方式是[ start, end )半闭区间的模式，即索引start可以引用到，而end是不能引用到的\nstart可以没有，默认为0；end可以没有默认cap\n删除\n1 2 3 4 5 6 7 8 9 10 s := []int{0, 1, 2, 3, 4, 5} // 删除go切片首尾元素的方法 s = s[1:] //利用切片引用并重新赋值的方法，删除掉首尾元素，如果想删除两个，可以用s=s[2:] fmt.Println(s) //[1,2,3,4,5] s = s[0:(len(s) - 1)] //删除末尾的元素 fmt.Println(s) //[1,2,3,4] // 接下来，我们利用append()方法来删除切片中间位置的元素 s = append(s[:1], s[2:]...) fmt.Println(s) //[1,3,4] 复制\n切片共用底层数组，修改的话有可能影响原来的切片，如果我们不想这样，可以使用copy\n1 2 3 4 5 6 7 8 9 s0 := []int{1, 0, 3, 2, 6, 5} s1 := make([]int, len(s0)) s2 := s0 copy(s1, s0) fmt.Printf(\u0026#34;s0的内存地址为%p，s1的内存地址为%p，s2的内存地址为%p \\n\u0026#34;, \u0026amp;s0, \u0026amp;s1, \u0026amp;s2) s1[0] = 100 fmt.Printf(\u0026#34;s1元素修改后，s1的值为%v, s0的值为%v \\n\u0026#34;, s1, s0) s0[0] = 99 fmt.Printf(\u0026#34;s0元素修改后，s0的值为%v，s2的值为%v，s1的值为%v \\n\u0026#34;, s0, s2, s1) s0,s2相互影响，而s1则跟s0,s2没有关系\n","permalink":"https://PheonixHkbxoic.github.io/docs/en/posts/golang/slice/","summary":"切片是不定长的特定元素类型的序列,可以理解为动态数组,切片本身不能存储任何数据，都是底层数组存储数据，修改切片的时候修改的是底层数组中的数据,底层实现是一个结构体，包括长度、容量和一个指向实际数组的unsafe.Pointer指针","title":"Go: Slice"},{"content":"range 用于迭代数组、切片、映射、字符串和通道等数据结构。\n通过range，可以逐个访问集合中的元素。\n特点 对于数组、切片、字符串，range返回索引和对应的值。 字符串返回的是rune而不是字节 对于映射，range返回键和对应的值。 对于通道，range会遍历通道直到关闭, 没有数据则会阻塞。 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 // 1.数组或arr := []int{1, 2, 3} // 可以只使用索引 for index := range arr{ } // 可以只使用value for _, value := range arr{ } // 全部使用 for index, value := range arr{ } // 也可以只循环次数 for range arr{ } // 遍历nil也不报错， 循环一次也不执行 for range nil{ } // 2.字典 m := map[string]int{ \u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: 2, \u0026#34;c\u0026#34;: 3 } for k, v := range m { } // 3.通道 ch := make(chan int) go func(){ ch \u0026lt;- 1 ch \u0026lt;- 2 close(ch) } // 打印1和2 for data := range ch{ fmt.Println(data) } 注意事项 对于channel，没有数据时，会被阻塞\n尽量避免遍历过程中修改原数据\nindex、value接收range返回值会发生一次值深拷贝，但变量指针地址是不变的\n1 2 3 4 5 6 arr := []int{1, 2, 3} for i, v := range arr { fmt.Println(\u0026amp;v, \u0026amp;arr[i]) // 每次v的值在变，但是v的地址(\u0026amp;v)是不变的 // 最后\u0026amp;v会指向数组最后一个元素 } Go中所有赋值都是值传递，所以直接修改v的值，数组元素不会发生变化\n值类型复制(赋值)都是深拷贝，引用类型一般都是浅拷贝。\n深浅拷贝的本质就是看拷贝内容是数据还是数据的地址。 如果结构中不含指针，则直接赋值就是深度拷贝； 如果结构中含有指针（包括自定义指针，以及切片，map等使用了指针的内置类型）是浅拷贝\n这意味着v.Xxx(是指针的话)改的话，数组元素的Xxx也会变\n特别注意：如果元素是指针，它也是值传递，拷贝的是指针，是浅拷贝，所以操作指针会使对应的值都改变\n数组与切片循环前次数已确定，所以新添加的元素无法遍历\nmap的遍历是随机的，所以新添加的数据可能立即遍历到，也可能不会遍历到\n","permalink":"https://PheonixHkbxoic.github.io/docs/en/posts/golang/range/","summary":"迭代数组、切片、映射、字符串和通道,i,v是值传递，修改v数组元素不变， 数组与切片循环前次数已确定，遍历通道直到关闭, 没有数据则会阻塞","title":"Go: range"},{"content":"字符串 声明与赋值 1 2 3 4 5 var a string var a string = \u0026#34;x\u0026#34; var a = \u0026#34;x\u0026#34; a := \u0026#34;x\\\u0026#34;x\u0026#34; a := `x\u0026#34;x` 数据结构 1 2 3 4 type StringHeader struct { Data uintptr Len int } Data是数据的地址，Len是数据的长度\nuintptr不参与gc\n本质上是字节数组\n字符串是不可变的\n字符串的赋值并不是拷贝底层的字符串数组，而是数组指针和长度字段的拷贝\n1 2 3 4 5 6 7 8 9 a := \u0026#34;hello,world\u0026#34; b := a fmt.Println(a) fmt.Println(b) fmt.Printf(\u0026#34;%x, %x\\n\u0026#34;, \u0026amp;a, \u0026amp;b) aptr := (*reflect.StringHeader) (unsafe.Pointer(\u0026amp;a)) bptr := (*reflect.StringHeader) (unsafe.Pointer(\u0026amp;b)) fmt.Println(\u0026#34;a data ptr:\u0026#34;, unsafe.Pointer(aptr.Data)) fmt.Println(\u0026#34;b data ptr:\u0026#34;, unsafe.Pointer(bptr.Data)) 输出\n1 2 3 4 5 6 7 8 9 10 11 // a,b的字符串一样 hello,world hello,world // a,b的指针不一样，显然b是对a的StringHeader复制了一份 c0000543d0, c0000543e0 // a,b的Data一样，指向的数据是同一个 a data ptr: 0xfda3cf b data ptr: 0xfda3cf // 所以 字符串的赋值是浅拷贝 重新赋值 不会改变原来变量的地址，即StringHeader还是同一个，但Data已指向了新的数据地址\n其他操作都是深拷贝，如传参，切分，拼接，转换\n与字节数组、字符数组的相互转换 字符串转换成字节数组\nbs := []byte(a)\n字节数组转换成字符串\nb := string(bs)\n需要说明的是 字节数组并不等于字符数组，因为非ASCII字符一般会占多个字节\n所以字节数并不一定等于字符数 字符串转换成字符数组\ncs := []rune(a)\n字符数组转换成字符串\nc := string(cs)\n字符串拼接 使用+直接拼接 使用Strings.Builder 使用strings.Join方法 字符串比较 == 区分大小写，比Compare快 strings.Compare 区分大小写 strings.EqualFold 不区分大小写 ","permalink":"https://PheonixHkbxoic.github.io/docs/en/posts/golang/string/","summary":"字符串是不可变的,字符串的赋值并不是拷贝底层的字符串数组，而是数组指针和长度字段的拷贝,重新赋值 不会改变原来变量的地址","title":"Go: string"},{"content":"一、变量声明与赋值 Go 中命名规则是，名称以字母或下划线开头，后面可跟任意数量的字符、数字和下划线，字符区分大小写，名称本身没有长度限制，但是 Go 的编程风格倾向于使用短名称，特别是局部变量.\nGo 中有 25 个关键字，这些关键字不可用来命名。\nbreak default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var 单变量声明与赋值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 声明 默认值为0 var a int // 声明并赋值 var c int = 3 var b = 1 // 单独赋值 a = 2 // 不能重复声明 // 简短声明：声明并赋值 简化形式 d := 4 fmt.Println(a, b, c, d) 多变量声明与赋值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // 多变量 声明 var aa, bb int fmt.Println(aa, bb) // 多变量 声明并赋值 var cc, dd int = 1, 2 var cc2, dd2 = 1, 2 fmt.Println(cc, dd, cc2, dd2) // 多变量 声明并赋值 简化形式 ee, ff := 1, 2 fmt.Println(ee, ff) // 只要有一个变量没声明过 就不会报错 ee, fff := 1, 2 fmt.Println(ee, fff) // 全部都声明过 报错 //ee, ff := 1, 2 // 多变量 但不同类型 var ( aaa int bbb string aaa2 = 3 bbb2 = \u0026#34;\u0026#34; ) fmt.Println(aaa, bbb, aaa2, bbb2) // 多变量 但不同类型 简化形式 ccc, ddd := 3, \u0026#34;\u0026#34; fmt.Println(ccc, ddd) 全局变量与局部变量 1 2 3 4 5 6 7 8 // 全局变量 只声明赋值 可以不使用 不会报错 var x int func main() { // 局部变量 只声明 可以会报错 //var xx int = 4 } 赋值类型不同时 1 2 3 4 5 6 7 8 9 10 11 // 赋值类型不同时 可能会强转，不能强转则会报错 var mi int = 5.0 fmt.Println(mi) // \u0026#39;\u0026#34;5.0\u0026#34;\u0026#39; (type string) cannot be represented by the type int //var mii int = \u0026#34;5.0\u0026#34; //fmt.Println(mii) // 可以自己转 var mx int = int(5.0) mii, _ := strconv.Atoi(\u0026#34;5.0\u0026#34;) fmt.Println(mx, mii) 常量 1 2 3 4 5 6 7 8 9 10 const a = 5 const b float32 = 5.0 const c = \u0026#34;abc\u0026#34; const ( x = true y = complex(3.0, 2.0) z uint = 5 m = iota ) 常量类型可以省略，由编译器自动推断，是在编译时预告处理的，而不是在运行时 常量只能是基本数据类型，包括整数、浮点数、布尔值和字符串 常量不允许被重复定义 二、常见类型 布尔bool, 字符串string, 整数(integer)，浮点数(float)，复数(complex)\n接口interface{}，结构体struct，数组(array)，切片(slice)，通道chan，字典map，函数func()\n括号中的类型并不存在，只是一个统称\n整数：byte, int(默认), int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64, rune, uintptr\n浮点数：float32(默认), float64\n复数：complex64, complex128\n注:\nbyte=uint8, rune=int32, 而int、uint、uintptr的大小是不确定的，取决取系统，可能为32或64位 uintptr只是一个无符号整形，一般是地址值，不是指针，不参与gc，需要通过uintptr(unsafe.Pointer(指针变量))强转得到 unsafe.Pointer指针对象，参与gc，可通过unsafe.Pointer(指针变量)得到 any任意类型，即interface{}接口 三、零值，默认值 bool: false string: \u0026quot;\u0026quot; 整数：0 浮点数：0 复数: (0+0i) 数组：元素的默认值 结构体：字段类型的默认值 接口，数组，切片，通道，字典，函数的零值都是nil，但数组与切片的默认值为[],字典的默认值为[] 注：不同类型的值不能相互比较，nil实际上也有很多类型，不同类型的nil也不相等，nil != nil\n","permalink":"https://PheonixHkbxoic.github.io/docs/en/posts/golang/variable/","summary":"一、变量声明与赋值 Go 中命名规则是，名称以字母或下划线开头，后面可跟任意数量的字符、数字和下划线，字符区分大小写，名称本身没有长度限制，但是 Go","title":"Go: variable"}]