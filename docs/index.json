[{"content":"字符串 声明与赋值 1 2 3 4 5 var a string var a string = \u0026#34;x\u0026#34; var a = \u0026#34;x\u0026#34; a := \u0026#34;x\\\u0026#34;x\u0026#34; a := `x\u0026#34;x` 数据结构 1 2 3 4 type StringHeader struct { Data uintptr Len int } Data是数据的地址，Len是数据的长度 uintptr不参与gc 本质上是字节数组 字符串是不可变的 字符串的赋值并不是拷贝底层的字符串数组，而是数组指针和长度字段的拷贝 1 2 3 4 5 6 7 8 9 10 11 12 a := \u0026#34;hello,world\u0026#34; b := a fmt.Println(a) fmt.Println(b) fmt.Printf(\u0026#34;%x, %x\\n\u0026#34;, \u0026amp;a, \u0026amp;b) aptr := (*reflect.StringHeader) (unsafe.Pointer(\u0026amp;a)) bptr := (*reflect.StringHeader) (unsafe.Pointer(\u0026amp;b)) fmt.Println(\u0026#34;a data ptr:\u0026#34;, unsafe.Pointer(aptr.Data)) fmt.Println(\u0026#34;b data ptr:\u0026#34;, unsafe.Pointer(bptr.Data)) 1 2 3 4 5 6 7 8 9 10 11 // a,b的字符串一样 hello,world hello,world // a,b的指针不一样，显然b是对a的StringHeader复制了一份 c0000543d0, c0000543e0 // a,b的Data一样，指向的数据是同一个 a data ptr: 0xfda3cf b data ptr: 0xfda3cf // 所以 字符串的赋值是浅拷贝 重新赋值 不会改变原来变量的地址，即StringHeader还是同一个，但Data已指向了新的数据地址 其他操作都是深拷贝，如传参，切分，拼接，转换 与字节数组、字符数组的相互转换 字符串转换成字节数组\nbs := []byte(a)\n字节数组转换成字符串\nb := string(bs)\n需要说明的是 字节数组并不等于字符数组，因为非ASCII字符一般会占多个字节\n所以字节数并不一定等于字符数 字符串转换成字符数组\ncs := []rune(a)\n字符数组转换成字符串\nc := string(cs)\n字符串拼接 使用+直接拼接 使用Strings.Builder 使用strings.Join方法 字符串比较 == 区分大小写，比Compare快 strings.Compare 区分大小写 strings.EqualFold 不区分大小写 ","permalink":"https://PheonixHkbxoic.github.io/docs/posts/golang/string/","summary":"字符串 声明与赋值 1 2 3 4 5 var a string var a string = \u0026#34;x\u0026#34; var a = \u0026#34;x\u0026#34; a := \u0026#34;x\\\u0026#34;x\u0026#34; a := `x\u0026#34;x` 数据结构 1 2 3 4 type StringHeader struct { Data uintptr Len int } Data是数据的地址，Len是数据的长度 ui","title":"Go: string"},{"content":"一、变量声明与赋值 Go 中命名规则是，名称以字母或下划线开头，后面可跟任意数量的字符、数字和下划线，字符区分大小写，名称本身没有长度限制，但是 Go 的编程风格倾向于使用短名称，特别是局部变量.\nGo 中有 25 个关键字，这些关键字不可用来命名。\nbreak default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var 单变量声明与赋值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 声明 默认值为0 var a int // 声明并赋值 var c int = 3 var b = 1 // 单独赋值 a = 2 // 不能重复声明 // 简短声明：声明并赋值 简化形式 d := 4 fmt.Println(a, b, c, d) 多变量声明与赋值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // 多变量 声明 var aa, bb int fmt.Println(aa, bb) // 多变量 声明并赋值 var cc, dd int = 1, 2 var cc2, dd2 = 1, 2 fmt.Println(cc, dd, cc2, dd2) // 多变量 声明并赋值 简化形式 ee, ff := 1, 2 fmt.Println(ee, ff) // 只要有一个变量没声明过 就不会报错 ee, fff := 1, 2 fmt.Println(ee, fff) // 全部都声明过 报错 //ee, ff := 1, 2 // 多变量 但不同类型 var ( aaa int bbb string aaa2 = 3 bbb2 = \u0026#34;\u0026#34; ) fmt.Println(aaa, bbb, aaa2, bbb2) // 多变量 但不同类型 简化形式 ccc, ddd := 3, \u0026#34;\u0026#34; fmt.Println(ccc, ddd) 全局变量与局部变量 1 2 3 4 5 6 7 8 // 全局变量 只声明赋值 可以不使用 不会报错 var x int func main() { // 局部变量 只声明 可以会报错 //var xx int = 4 } 赋值类型不同时 1 2 3 4 5 6 7 8 9 10 11 // 赋值类型不同时 可能会强转，不能强转则会报错 var mi int = 5.0 fmt.Println(mi) // \u0026#39;\u0026#34;5.0\u0026#34;\u0026#39; (type string) cannot be represented by the type int //var mii int = \u0026#34;5.0\u0026#34; //fmt.Println(mii) // 可以自己转 var mx int = int(5.0) mii, _ := strconv.Atoi(\u0026#34;5.0\u0026#34;) fmt.Println(mx, mii) 常量 1 2 3 4 5 6 7 8 9 10 const a = 5 const b float32 = 5.0 const c = \u0026#34;abc\u0026#34; const ( x = true y = complex(3.0, 2.0) z uint = 5 m = iota ) 常量类型可以省略，由编译器自动推断，是在编译时预告处理的，而不是在运行时 常量只能是基本数据类型，包括整数、浮点数、布尔值和字符串 常量不允许被重复定义 二、常见类型 布尔bool, 字符串string, 整数(integer)，浮点数(float)，复数(complex)\n接口interface{}，结构体struct，数组(array)，切片(slice)，通道chan，字典map，函数func()\n括号中的类型并不存在，只是一个统称\n整数：byte, int(默认), int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64, rune, uintptr\n浮点数：float32(默认), float64\n复数：complex64, complex128\n注:\nbyte=uint8, rune=int32, 而int、uint、uintptr的大小是不确定的，取决取系统，可能为32或64位 uintptr只是一个无符号整形，一般是地址值，不是指针，不参与gc，需要通过uintptr(unsafe.Pointer(指针变量))强转得到 unsafe.Pointer指针对象，参与gc，可通过unsafe.Pointer(指针变量)得到 any任意类型，即interface{}接口 三、零值，默认值 bool: false string: \u0026quot;\u0026quot; 整数：0 浮点数：0 复数: (0+0i) 数组：元素的默认值 结构体：字段类型的默认值 接口，数组，切片，通道，字典，函数的零值都是nil，但数组与切片的默认值为[],字典的默认值为[] 注：不同类型的值不能相互比较，nil实际上也有很多类型，不同类型的nil也不相等，nil != nil\n","permalink":"https://PheonixHkbxoic.github.io/docs/posts/golang/variable_declaration/","summary":"一、变量声明与赋值 Go 中命名规则是，名称以字母或下划线开头，后面可跟任意数量的字符、数字和下划线，字符区分大小写，名称本身没有长度限制，但是 Go","title":"GO:变量声明与赋值"},{"content":"生活是一场修行 不断感悟，不断修行\n","permalink":"https://PheonixHkbxoic.github.io/docs/posts/life/life-perception-2023-12-29/","summary":"生活是一场修行 不断感悟，不断修行","title":"感悟"},{"content":"生活是一场旅行 旅行的意义就是在路上，然后看不同的风景\n","permalink":"https://PheonixHkbxoic.github.io/docs/posts/life/life-travel-2023-12-30/","summary":"生活是一场旅行 旅行的意义就是在路上，然后看不同的风景","title":"旅行"},{"content":"Spring Java是世界上最好的语言.go\nSpringBoot nacos\nSpringCloud fein,raibon\n","permalink":"https://PheonixHkbxoic.github.io/docs/posts/java/spring/","summary":"Spring Java是世界上最好的语言.go SpringBoot nacos SpringCloud fein,raibon","title":"java"},{"content":"GPT python ai crawler\n","permalink":"https://PheonixHkbxoic.github.io/docs/posts/python/gpt/","summary":"GPT python ai crawler","title":"python"},{"content":"友情链接 Hugo\n","permalink":"https://PheonixHkbxoic.github.io/docs/links/","summary":"友情链接 Hugo","title":"Links"}]