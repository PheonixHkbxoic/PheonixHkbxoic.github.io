[{"content":"字典 一、声明与赋值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 声明 指明key，value的类型 var a map[string]string // 赋值 a = map[string]string{} // 声明并赋值 var b map[string]string = map[string]string{} var c = map[string]string{ \u0026#34;a\u0026#34; : \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34; : \u0026#34;b\u0026#34;, } d := map[string]string{} // 使用make赋值, 没有容量参数 var e = make(map[string]string, 5) 二、注意事项 只声明的map未初始化, 为nil，添加元素会报错， 查询、删除不会报错相当于空操作 不支持并发，否则报错panic key的类型不同，hash的计算方式也不同 range遍历是随机的 ok可判断myKey是否存在：v,ok = m[\u0026ldquo;myKey\u0026rdquo;]；即使不存在v也是零值 查询键值对时，最好检查键是否存在，避免操作零值 delete删除键值对 map为引用类型，不能比较 数组和切片允许对元素进行取址操作，但不允许对map的元素进行取址操作 value可以是Go支持的任意数据类型，而key则所有限制 key的数据类型必须是可以使用==和!=进行比较\n所以，key不能是函数、切片、map，因此这些数据类型不能进行比较\n另外，而数组和结构体则可以作为map的key\n不过，如果数组的元素包含函数、切片、map，则数组不能作为map的key，结构体的字段如果有以上三者，也同样不能作为map的key。\n三、实现原理 3.1 插入 3.2 更新 3.3 扩容 ","permalink":"https://PheonixHkbxoic.github.io/docs/posts/golang/map/","summary":"字典 一、声明与赋值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 声明 指明key，value的类型 var a map[string]string // 赋值 a = map[string]string{} // 声明并赋值 var b map[string]string = map[string]string{} var c = map[string]string{ \u0026#34;a\u0026#34; : \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34; :","title":"Go: 字典"},{"content":"slice 切片是不定长的特定元素类型的序列,可以理解为动态数组\nGo语言中，数组在传递的时候，传递的是原数组的拷贝，对大数组来说，内存代价会非常大，影响性能。\n传递数组指针可以解决这个问题，但是数组指针也有一个弊端：原数组的指针指向改变了，那函数里面的指针指向也会跟着改变，某些情况下，可能会产生意想不到的bug。slice的出现，便是为了解决这个问题。\n一、特点 长度不固定 切片是引用类型，一般来说是浅拷贝 切片本身不能存储任何数据，都是底层数组存储数据，修改切片的时候修改的是底层数组中的数据，切片一旦扩容，会指向一个新的底层数组，内存地址也就随之改变。 底层实现是一个结构体，包括长度、容量和一个指向实际数组的unsafe.Pointer指针 1 2 3 4 5 type slice struct { array unsafe.Pointer // 指向底层数组的指针 len int // 长度 cap int // 容量 } 注意：\n底层数组是可以被多个 slice 同时指向的，因此对一个 slice 的元素进行操作是有可能影响到其他 slice 的。\n二、扩容规则 如果扩容需求大于当前容量的两倍，扩容后的容量为所需的最小容量 当前切片长度\u0026lt;1024,扩容当前容量为2倍， 当前切片长度\u0026gt;1024,每次扩容当前容量的1.25倍，循环扩容直至容量满足需求\n切片扩容之后，指向匿名数组的指针地址会发生变化。 1.18 引入了新的扩容规则，首先 1024 的边界不复存在，取而代之的常量是 256 。超出256的情况，也不是直接扩容25%，而是设计了一个平滑过渡的计算方法，随着容量增大，扩容比例逐渐从100%平滑降低到25%，从 2 倍平滑过渡到 1.25 倍。\n为什么要这样设计？\n避免追加过程中频繁扩容，减少内存分配和数据复制开销，有助于性能提升。\n计算出了新容量之后，还没有完，出于内存的高效利用考虑，还要进行内存对齐。进行内存对齐之后，新 slice 的容量是要 大于等于 老 slice 容量的 2倍或者1.25倍。\n三、声明与赋值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 只声明 var a = []string // 声明，使用字面量初始化 var b = []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;} // 从已有数组或切片生成 var c = b[1:] // 使用make生成 可以指定长度，容量 var d = make([]string, 3) var d = make([]string, 3, 8) // new方式创建的是指针 var e *[]int = new([]int) 注意：\n只声明的切片 等于nil，长度与容量都为0 make([]string, 0, 0)赋值的切片，长度与容量都为0，但不是nil make会用零值0初始化所有元素, cap可心省略(默认等于长度) 四、切片slice和数组array的关系 切片slice的底层是对数组array的引用；\n切片可以引用数组的部分元素或者全部元素；\n切片slice的指针指向的是切片的第一个元素的内存地址，也就是该元素对应的数组的元素的内存地址。\n五、切片操作 len,cap 可以查看切片的长度与容量\nappend s = append(s, “x”)\ns作为参数传给函数append是值传递，是结构体的拷贝，底层数组的指针一样\n底层数组加了一个元素，s拷贝的长度也会跟着变，但s的长度没变啊，所以s要重新赋值\n另外如果扩容了s拷贝的底层数组指针会变, 长度，容量也会变，但原来的s什么都不会变，所以s也要重新赋值\n值的过程复制一个新的切片，这个切片也指向原始变量的底层数组。\n函数中无论是直接修改切片，还是append创建新的切片，都是基于共享切片底层数组的情况作为基础，\n最外面的原始切片是否改变，取决于函数内的操作和切片本身容量，是否修改了底层数组。\n如果要修改切片的值，那么一定对底层数组做了修改，为影响到函数外的切片 如果是append操作，则要看切片是否扩容 切片没有进行扩容，那么会直接添加或修改切片指向底层数组中后一位的值，故底层数组会受到改变，函数外切片改变； 而如果进行扩容，则会导致切片指向一个新的底层数组，一切修改都对函数外的原切片无影响 访问 切片的引用方式是[ start, end )半闭区间的模式，即索引start可以引用到，而end是不能引用到的\nstart可以没有，默认为0；end可以没有默认cap\n删除\n1 2 3 4 5 6 7 8 9 10 s := []int{0, 1, 2, 3, 4, 5} // 删除go切片首尾元素的方法 s = s[1:] //利用切片引用并重新赋值的方法，删除掉首尾元素，如果想删除两个，可以用s=s[2:] fmt.Println(s) //[1,2,3,4,5] s = s[0:(len(s) - 1)] //删除末尾的元素 fmt.Println(s) //[1,2,3,4] // 接下来，我们利用append()方法来删除切片中间位置的元素 s = append(s[:1], s[2:]...) fmt.Println(s) //[1,3,4] 复制\n切片共用底层数组，修改的话有可能影响原来的切片，如果我们不想这样，可以使用copy\n1 2 3 4 5 6 7 8 9 s0 := []int{1, 0, 3, 2, 6, 5} s1 := make([]int, len(s0)) s2 := s0 copy(s1, s0) fmt.Printf(\u0026#34;s0的内存地址为%p，s1的内存地址为%p，s2的内存地址为%p \\n\u0026#34;, \u0026amp;s0, \u0026amp;s1, \u0026amp;s2) s1[0] = 100 fmt.Printf(\u0026#34;s1元素修改后，s1的值为%v, s0的值为%v \\n\u0026#34;, s1, s0) s0[0] = 99 fmt.Printf(\u0026#34;s0元素修改后，s0的值为%v，s2的值为%v，s1的值为%v \\n\u0026#34;, s0, s2, s1) s0,s2相互影响，而s1则跟s0,s2没有关系\n","permalink":"https://PheonixHkbxoic.github.io/docs/posts/golang/slice/","summary":"切片是不定长的特定元素类型的序列,可以理解为动态数组,切片本身不能存储任何数据，都是底层数组存储数据，修改切片的时候修改的是底层数组中的数据,底层实现是一个结构体，包括长度、容量和一个指向实际数组的unsafe.Pointer指针","title":"Go: 切片"},{"content":"数组 数组是存放在连续内存空间上的相同类型数据的集合。查询简单，增加和删除困难。\n数组可以通过下标快速访问数组元素。但是因为数组在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。数组的元素是不能删的，只能覆盖。\n二维数组在内存的空间地址也是连续的\n一、声明与赋值 1 2 3 4 var a [3]int var b = [3]int{1,2,3} c := [3]int{1,2,3} d := [...]int{1,2,3} 数组是内存中一片连续的区域，跟Slice，Map等结构体完全不一样\n需要指定长度，是个常量，不能动态指定，[\u0026hellip;]方式在编译时自动推断\n元素类型相同\n是值类型，类型与长度都相同时才被认为两个数组是同类型\n二、编译时检测、内存分配 数组在编译阶段最终被解析为types.Array类型，包含元素类型Elem和数组长度Bound\n1 2 3 4 5 // Array contains Type fields specific to array types. type Array struct { Elem *Type // element type Bound int64 // number of elements; \u0026lt;0 if unknown yet } 并会进行类型检查 ，索引越界检查\n三、运行时 当编译时无法判断是否越界时，SSA生成 IsInBounds 越界检查指令，若越界，触发 PanicBounds 指令执行 runtime.panicIndex\n运行时通过newarray()函数对数组内存进行分配，如果数组大小不超过32kb则会直接分配到栈上， 否则分配到堆区内存\n四、注意 Go中的传值方式是按值传递，这意味着给变量赋值、给函数传参时，都是直接拷贝一个副本然后将副本赋值给对方的。这样的拷贝方式意味着：\n如果数据结构体积庞大，则要完整拷贝一个数据结构副本时效率会很低 函数内部修改数据结构时，只能在函数内部生效，函数一退出就失效了，因为它修改的是副本对象 五、参考 golang数组内存分配原理_Golang_脚本之家\n","permalink":"https://PheonixHkbxoic.github.io/docs/posts/golang/array/","summary":"数组是内存中一片连续的区域，固定长度，元素类型相同，是值类型，大数组值参等值传递效率低 编译时进行类型检查 ，索引越界检查","title":"Go: 数组"},{"content":"range 用于迭代数组、切片、映射、字符串和通道等数据结构。\n通过range，可以逐个访问集合中的元素。\n特点 对于数组、切片、字符串，range返回索引和对应的值。 字符串返回的是rune而不是字节 对于映射，range返回键和对应的值。 对于通道，range会遍历通道直到关闭, 没有数据则会阻塞。 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 // 1.数组或arr := []int{1, 2, 3} // 可以只使用索引 for index := range arr{ } // 可以只使用value for _, value := range arr{ } // 全部使用 for index, value := range arr{ } // 也可以只循环次数 for range arr{ } // 遍历nil也不报错， 循环一次也不执行 for range nil{ } // 2.字典 m := map[string]int{ \u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: 2, \u0026#34;c\u0026#34;: 3 } for k, v := range m { } // 3.通道 ch := make(chan int) go func(){ ch \u0026lt;- 1 ch \u0026lt;- 2 close(ch) } // 打印1和2 for data := range ch{ fmt.Println(data) } 注意事项 对于channel，没有数据时，会被阻塞\n尽量避免遍历过程中修改原数据\nindex、value接收range返回值会发生一次值深拷贝，但变量指针地址是不变的\n1 2 3 4 5 6 arr := []int{1, 2, 3} for i, v := range arr { fmt.Println(\u0026amp;v, \u0026amp;arr[i]) // 每次v的值在变，但是v的地址(\u0026amp;v)是不变的 // 最后\u0026amp;v会指向数组最后一个元素 } Go中所有赋值都是值传递，所以直接修改v的值，数组元素不会发生变化\n值类型复制(赋值)都是深拷贝，引用类型一般都是浅拷贝。\n深浅拷贝的本质就是看拷贝内容是数据还是数据的地址。 如果结构中不含指针，则直接赋值就是深度拷贝； 如果结构中含有指针（包括自定义指针，以及切片，map等使用了指针的内置类型）是浅拷贝\n这意味着v.Xxx(是指针的话)改的话，数组元素的Xxx也会变\n特别注意：如果元素是指针，它也是值传递，拷贝的是指针，是浅拷贝，所以操作指针会使对应的值都改变\n数组与切片循环前次数已确定，所以新添加的元素无法遍历\nmap的遍历是随机的，所以新添加的数据可能立即遍历到，也可能不会遍历到\n","permalink":"https://PheonixHkbxoic.github.io/docs/posts/golang/range/","summary":"迭代数组、切片、映射、字符串和通道,i,v是值传递，修改v数组元素不变， 数组与切片循环前次数已确定，遍历通道直到关闭, 没有数据则会阻塞","title":"Go: range迭代"},{"content":"通道 在Go语言中，channel是一种特殊的类型，用于在并发编程中实现不同的goroutine之间的通信和同步。本文将深入探讨golang的channel是如何工作的，并介绍如何使用channel来提高程序的性能和可靠性。\n一、什么是Channel 在Go语言中，使用goroutine单纯地将函数并发执行是没有意义的。函数与函数间需要交换数据才能体现并发执行函数的意义。\n虽然可以使用共享内存进行数据交换，但是共享内存在不同的goroutine中容易发生竞态问题。为了保证数据交换的正确性，必须使用互斥量对内存进行加锁，这种做法势必造成性能问题。\nGo语言的并发模型是CSP（Communicating Sequential Processes），提倡通过通信共享内存而不是通过共享内存而实现通信。\n如果说goroutine是Go程序并发的执行体，channel就是它们之间的连接。channel是可以让一个goroutine发送特定值到另一个goroutine的通信机制。\nChannel是Go中的一个核心类型，你可以把它看成一个管道，通过它并发核心单元就可以发送或者接收数据进行通讯(communication)。\nChannel提供了一种同步的机制，确保在数据发送和接收之间的正确顺序和时机。通过使用channel，我们可以避免在多个goroutine之间共享数据时出现的竞争条件和其他并发问题。\nGo 语言中的通道（channel）是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。\nChannel的操作符是箭头 \u0026lt;- (箭头的指向就是数据的流向)。\n二、声明与赋值 1 2 3 4 // var 变量 chan 元素类型 var ch chan string // make(chan 元素类型, [容量]) c := make(chan string, 10) 只声明的chan零值为nil，无论发送与接收都会阻塞 需要使用make创建并赋值，容量可不写或为0 表示无缓冲 无缓冲通道必须至少有一个接收方才能发送成功，同理至少有一个发送放才能接收成功 chan有三种操作 ch \u0026lt;- \u0026ldquo;abc\u0026rdquo; 表示发送 \u0026lt;- ch 表示接收 close(ch) 表示关闭 chan有方向，一般用在函数参数声明时，对通道操作进行限制 c chan \u0026lt;- string表示通道c只能发送数据 c \u0026lt;- chan string表示通道c只能接收数据 c chan string表示通道c可以发送和接收数据 panic出现的情况 关闭值为nil的通道，会panic close后再发送数据，会panic 重复close，会panic 阻塞出现的情况 通道为nil，无论发送与接收都会阻塞 无缓冲通道必须至少有一个接收方才能发送成功，同理至少有一个发送放才能接收成功 有缓冲时：缓冲为空时接收方阻塞， 缓冲满时发送方阻塞 关闭通道后接收方能接收数据直到数据为空，但是还会返回数据 v, ok := \u0026lt;- ch此时ok为false，v为对应数据的零值；可用于检测通道是否关闭 三、接收数据 channel 有一个特性：close关闭之后，在发送的时候会 panic，但是在接收的时候，是可以正常接收的。\n1. for-range 1 2 3 for v := range ch { } range ch会一起迭代直到ch关闭，如果没有数据则会阻塞\n2. for{}死循环 1 2 3 4 5 6 7 for { v, ok := \u0026lt;- ch if !ok { break } fmt.Println(v) } for{}列表循环的关键是要判断ch是否已关闭，如果已关闭则可退出死循环\n通道中有数据则会接收到值，否则会阻塞\n3. select 上面两种方式都是从单通道中接收数据，而select可处理多个通道\nselect类似switch, 一次只能处理一个case，它不是循环for select只能用于channel 若想一直处理数据，要在外面加for{}死循环 1 2 3 4 5 6 7 8 9 10 for { select { case v := \u0026lt;- ch: fmt.Println(v) case v2 := \u0026lt;- ch2: fmt.Println(v2) default: break } } 多个case分支满足时，则会伪随机选择一个处理 所有case都不满足时，没有default则阻塞，有default则处理default select能接收数据，也能用于发送数据 case和default都没有的select会永远阻塞 select中没有fallthough break case中可以没有break，即case执行完就退出select了 你也可以认为每个case最后会默认存在break 你加了break就代表提前退出select，break后面的代码不会执行 break不会退出for，除非使用标签进行break或使用goto return跟select,for,switch没关系；退出的是函数 switch有fallthough, 并且fallthough后面的条件不会进行判断 四、原理 hchan结构如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 type hchan struct { qcount uint // 当前队列中剩余元素个数 dataqsiz uint // 环形队列长度，即可以存放的元素个数 buf unsafe.Pointer // 环形队列指针 elemsize uint16 // 每个元素的大小 closed uint32 // 标识关闭状态 elemtype *_type // 元素类型 sendx uint // 队列下标，指示元素写入时存放到队列中的位置 recvx uint // 队列下标，指示元素从队列的该位置读出 recvq waitq // 等待读消息的goroutine队列，即等待接收队列 sendq waitq // 等待写消息的goroutine队列，即等待发送队列 lock mutex // 互斥锁，chan不允许并发读写 } 五、参考链接 go channel 万字详解 Go Channel的基本使用及底层原理详解 ","permalink":"https://PheonixHkbxoic.github.io/docs/posts/golang/channel/","summary":"通道 在Go语言中，channel是一种特殊的类型，用于在并发编程中实现不同的goroutine之间的通信和同步。本文将深入探讨golang的","title":"Go: Channel"},{"content":"字符串 声明与赋值 1 2 3 4 5 var a string var a string = \u0026#34;x\u0026#34; var a = \u0026#34;x\u0026#34; a := \u0026#34;x\\\u0026#34;x\u0026#34; a := `x\u0026#34;x` 数据结构 1 2 3 4 type StringHeader struct { Data uintptr Len int } Data是数据的地址，Len是数据的长度\nuintptr不参与gc\n本质上是字节数组\n字符串是不可变的\n字符串的赋值并不是拷贝底层的字符串数组，而是数组指针和长度字段的拷贝\n1 2 3 4 5 6 7 8 9 a := \u0026#34;hello,world\u0026#34; b := a fmt.Println(a) fmt.Println(b) fmt.Printf(\u0026#34;%x, %x\\n\u0026#34;, \u0026amp;a, \u0026amp;b) aptr := (*reflect.StringHeader) (unsafe.Pointer(\u0026amp;a)) bptr := (*reflect.StringHeader) (unsafe.Pointer(\u0026amp;b)) fmt.Println(\u0026#34;a data ptr:\u0026#34;, unsafe.Pointer(aptr.Data)) fmt.Println(\u0026#34;b data ptr:\u0026#34;, unsafe.Pointer(bptr.Data)) 输出\n1 2 3 4 5 6 7 8 9 10 11 // a,b的字符串一样 hello,world hello,world // a,b的指针不一样，显然b是对a的StringHeader复制了一份 c0000543d0, c0000543e0 // a,b的Data一样，指向的数据是同一个 a data ptr: 0xfda3cf b data ptr: 0xfda3cf // 所以 字符串的赋值是浅拷贝 重新赋值 不会改变原来变量的地址，即StringHeader还是同一个，但Data已指向了新的数据地址\n其他操作都是深拷贝，如传参，切分，拼接，转换\n与字节数组、字符数组的相互转换 字符串转换成字节数组\nbs := []byte(a)\n字节数组转换成字符串\nb := string(bs)\n需要说明的是 字节数组并不等于字符数组，因为非ASCII字符一般会占多个字节\n所以字节数并不一定等于字符数 字符串转换成字符数组\ncs := []rune(a)\n字符数组转换成字符串\nc := string(cs)\n字符串拼接 使用+直接拼接 使用Strings.Builder 使用strings.Join方法 字符串比较 == 区分大小写，比Compare快 strings.Compare 区分大小写 strings.EqualFold 不区分大小写 ","permalink":"https://PheonixHkbxoic.github.io/docs/posts/golang/string/","summary":"字符串是不可变的,字符串的赋值并不是拷贝底层的字符串数组，而是数组指针和长度字段的拷贝,重新赋值 不会改变原来变量的地址","title":"Go: 字符串"},{"content":"一、变量声明与赋值 Go 中命名规则是，名称以字母或下划线开头，后面可跟任意数量的字符、数字和下划线，字符区分大小写，名称本身没有长度限制，但是 Go 的编程风格倾向于使用短名称，特别是局部变量.\nGo 中有 25 个关键字，这些关键字不可用来命名。\nbreak default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var 单变量声明与赋值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 声明 默认值为0 var a int // 声明并赋值 var c int = 3 var b = 1 // 单独赋值 a = 2 // 不能重复声明 // 简短声明：声明并赋值 简化形式 d := 4 fmt.Println(a, b, c, d) 多变量声明与赋值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // 多变量 声明 var aa, bb int fmt.Println(aa, bb) // 多变量 声明并赋值 var cc, dd int = 1, 2 var cc2, dd2 = 1, 2 fmt.Println(cc, dd, cc2, dd2) // 多变量 声明并赋值 简化形式 ee, ff := 1, 2 fmt.Println(ee, ff) // 只要有一个变量没声明过 就不会报错 ee, fff := 1, 2 fmt.Println(ee, fff) // 全部都声明过 报错 //ee, ff := 1, 2 // 多变量 但不同类型 var ( aaa int bbb string aaa2 = 3 bbb2 = \u0026#34;\u0026#34; ) fmt.Println(aaa, bbb, aaa2, bbb2) // 多变量 但不同类型 简化形式 ccc, ddd := 3, \u0026#34;\u0026#34; fmt.Println(ccc, ddd) 全局变量与局部变量 1 2 3 4 5 6 7 8 // 全局变量 只声明赋值 可以不使用 不会报错 var x int func main() { // 局部变量 只声明 可以会报错 //var xx int = 4 } 赋值类型不同时 1 2 3 4 5 6 7 8 9 10 11 // 赋值类型不同时 可能会强转，不能强转则会报错 var mi int = 5.0 fmt.Println(mi) // \u0026#39;\u0026#34;5.0\u0026#34;\u0026#39; (type string) cannot be represented by the type int //var mii int = \u0026#34;5.0\u0026#34; //fmt.Println(mii) // 可以自己转 var mx int = int(5.0) mii, _ := strconv.Atoi(\u0026#34;5.0\u0026#34;) fmt.Println(mx, mii) 常量 1 2 3 4 5 6 7 8 9 10 const a = 5 const b float32 = 5.0 const c = \u0026#34;abc\u0026#34; const ( x = true y = complex(3.0, 2.0) z uint = 5 m = iota ) 常量类型可以省略，由编译器自动推断，是在编译时预告处理的，而不是在运行时 常量只能是基本数据类型，包括整数、浮点数、布尔值和字符串 常量不允许被重复定义 二、常见类型 布尔bool, 字符串string, 整数(integer)，浮点数(float)，复数(complex)\n接口interface{}，结构体struct，数组(array)，切片(slice)，通道chan，字典map，函数func()\n括号中的类型并不存在，只是一个统称\n整数：byte, int(默认), int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64, rune, uintptr\n浮点数：float32(默认), float64\n复数：complex64, complex128\n注:\nbyte=uint8, rune=int32, 而int、uint、uintptr的大小是不确定的，取决取系统，可能为32或64位 uintptr只是一个无符号整形，一般是地址值，不是指针，不参与gc，需要通过uintptr(unsafe.Pointer(指针变量))强转得到 unsafe.Pointer指针对象，参与gc，可通过unsafe.Pointer(指针变量)得到 any任意类型，即interface{}接口 三、零值，默认值 bool: false string: \u0026quot;\u0026quot; 整数：0 浮点数：0 复数: (0+0i) 数组：元素的默认值 结构体：字段类型的默认值 接口，数组，切片，通道，字典，函数的零值都是nil，但数组与切片的默认值为[],字典的默认值为[] 注：不同类型的值不能相互比较，nil实际上也有很多类型，不同类型的nil也不相等，nil != nil\n","permalink":"https://PheonixHkbxoic.github.io/docs/posts/golang/variable/","summary":"一、变量声明与赋值 Go 中命名规则是，名称以字母或下划线开头，后面可跟任意数量的字符、数字和下划线，字符区分大小写，名称本身没有长度限制，但是 Go","title":"Go: 变量"},{"content":"生活是一场修行 不断感悟，不断修行\n","permalink":"https://PheonixHkbxoic.github.io/docs/posts/life/life-perception-2023-12-29/","summary":"生活是一场修行 不断感悟，不断修行","title":"感悟"},{"content":"生活是一场旅行 旅行的意义就是在路上，然后看不同的风景\n","permalink":"https://PheonixHkbxoic.github.io/docs/posts/life/life-travel-2023-12-30/","summary":"生活是一场旅行 旅行的意义就是在路上，然后看不同的风景","title":"旅行"},{"content":"Spring Java是世界上最好的语言.go\nSpringBoot nacos\nSpringCloud fein,raibon\n","permalink":"https://PheonixHkbxoic.github.io/docs/posts/java/spring/","summary":"Spring Java是世界上最好的语言.go SpringBoot nacos SpringCloud fein,raibon","title":"java"},{"content":"GPT python ai crawler\n","permalink":"https://PheonixHkbxoic.github.io/docs/posts/python/gpt/","summary":"GPT python ai crawler","title":"python"},{"content":"友情链接 Hugo\n","permalink":"https://PheonixHkbxoic.github.io/docs/links/","summary":"友情链接 Hugo","title":"Links"}]